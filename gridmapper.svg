<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1"
     xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink">
  <desc>Gridmapper, a simple tool to create dungeon maps</desc>

  <script type="application/javascript"><![CDATA[
var svg_ns = "http://www.w3.org/2000/svg";
var xlink_ns = "http://www.w3.org/1999/xlink";
var Map = { width: 30, // how many columns
            height: 20, // how many rows
            tileWidth: 20, // tile size in pixels
            ui: null, // the SVG element with the event handlers
            floorElement: null, // the SVG element for the floor
            floor: new Array(), // the model for the floor
            stairsElement: null, // the SVG element for the stairs
            stairs: new Array(), // the model for the stairs
            wallsElement: null, // the SVG element for the walls
            walls: new Array(), // the model for the walls
          };

// http://javascript.info/tutorial/animation
function animate(opts) {
    var start = new Date;
    var id = setInterval(function() {
        var timePassed = new Date - start;
        var progress = timePassed / opts.duration;
        if (progress > 1) progress = 1;
        var delta = opts.delta(progress);
        opts.step(delta);
        if (progress == 1) {
            clearInterval(id);
        }
    }, opts.delay || 10);
}

function linear(progress) {
    return progress;
}

function bounce(progress) {
    for(var a = 0, b = 1, result; 1; a += b, b /= 2) {
        if (progress >= (7 - 4 * a) / 11) {
            return -Math.pow((11 - 6 * a - 11 * progress) / 4, 2) + Math.pow(b, 2)
        }
    }
}

function makeEaseOut(delta) {  
    return function(progress) {
        return 1 - delta(1 - progress);
    }
}

var bounceEaseOut = makeEaseOut(bounce);

function resize(element, to_width, to_height, delta, duration) {
    var from_width  = element.getBBox().width;  // assuming px
    var from_height = element.getBBox().height; // assuming px
    animate({
        delay: 10,
        duration: duration || 1000, // 1 sec by default
        delta: delta,
        step: function(delta) {
            element.setAttribute("width",  from_width  + (to_width  - from_width)  * delta);
            element.setAttribute("height", from_height + (to_height - from_height) * delta);
        }
    })
}

function move(element, dx, dy, delta, duration) {
    animate({
        delay: 10,
        duration: duration || 1000, // 1 sec by default
        delta: delta,
        step: function(delta) {
            element.setAttribute("transform", "translate(" + dx * delta + "," + dy * delta + ")");
        }
    })
}

function scale_tiles() {
    var tiles = document.getElementsByTagName("defs")[0].childNodes;
    for (var i = 0; i < tiles.length; ++i) {
        if (tiles[i].nodeType != Node.ELEMENT_NODE) continue;
        var scale = Map.tileWidth / tiles[i].getAttribute("width");
        if (scale != 1) {
            tiles[i].setAttribute("transform", "scale("+scale+","+scale+")");
        }
    }
}

function create_tile(x, y, type) {
    var tile = document.createElementNS(svg_ns, "use");
    tile.setAttributeNS(null, "id", "cell_" + x + "_" + y);
    tile.setAttributeNS(null, "x", x * Map.tileWidth);
    tile.setAttributeNS(null, "y", y * Map.tileWidth);
    tile.type = type;
    tile.setAttributeNS(xlink_ns, "href", "#" + type);
    return tile;
}

function wall_rotation(x, y, rotate) {
    // find an unused rotation
    var candidate = [rotate,
                     (rotate + 90) % 360,
                     (rotate + 180) % 360,
                     (rotate + 270) % 360];
    var existingWalls = [];
    for (var i = 0; i < Map.walls[x][y].length; i++) {
        existingWalls.push(Map.walls[x][y][i].getAttribute("rotate"));
    }
    search: for (var c = 0; c < 4; c++) {
        for (var i = 0; i < existingWalls.length; i++) {
            if (candidate[c]==existingWalls[i]) {
                continue search;
            }
        }
        return candidate[c];
    }
}

function wall(x, y, type) {
    var now = new Date;
    if (Pen.type===type && Map.walls[x][y] != null && Pen.ts && now - Pen.ts <= 2000) {
        // we just placed a door: take the last one and rotate it
        var tile = Map.walls[x][y][Map.walls[x][y].length - 1];
        var rotate = wall_rotation(x, y, (parseInt(tile.getAttribute("rotate")) + 90) % 360);
        if (rotate != null) {
            tile.setAttribute("rotate", rotate);
            if (rotate===180 && type==="concealed") {
                tile.setAttributeNS(null,"transform", "translate("+Map.tileWidth+",0)");
            } else if (rotate > 0) {
                var cx = (x + 0.5) * Map.tileWidth;
                var cy = (y + 0.5) * Map.tileWidth;
                tile.setAttributeNS(null,"transform", "rotate("+rotate+","+cx+","+cy+")");
            } else {
                tile.removeAttributeNS(null,"transform");
            }
        }
    } else {
        // make sure the data structure exists
        if (!Map.walls[x][y]) {
            Map.walls[x][y] = new Array();
        }
        var rotate = wall_rotation(x, y, 0);
        if (rotate != null) {
            var tile = create_tile(x, y, type);
            tile.setAttribute("rotate", rotate);
            if (rotate===180 && type==="concealed") {
                tile.setAttributeNS(null,"transform", "translate("+Map.tileWidth+",0)");
            } else if (rotate > 0) {
                var cx = (x + 0.5) * Map.tileWidth;
                var cy = (y + 0.5) * Map.tileWidth;
                tile.setAttributeNS(null,"transform", "rotate("+rotate+","+cx+","+cy+")");
            }
            Map.walls[x][y].push(tile);
            Map.wallsElement.appendChild(tile);
        }
    }
    Pen.ts = now;
}

function remove_wall (x, y) {
    if (Map.walls[x][y] != null) {
        // take the last one and remove it
        var tile = Map.walls[x][y].pop();
        Map.wallsElement.removeChild(tile);
        // clean up
        if (Map.walls[x][y].length == 0) {
            Map.walls[x][y] = null;
        }
    }
}

function door(x, y) {
    wall(x, y, "door");
    Pen.type = "door";
}

function secret(x, y) {
    wall(x, y, "secret");
    Pen.type = "secret";
}

function concealed(x, y) {
    wall(x, y, "concealed");
    Pen.type = "concealed";
}

function gate(x, y) {
    wall(x, y, "gate");
    Pen.type = "gate";
}

function trap(x, y) {
    if (Map.floor[x][y] != null && Map.floor[x][y].type==="trap") {
        Map.floorElement.removeChild(Map.floor[x][y]);
        var tile = create_tile(x, y, "empty");
        Map.floor[x][y] = tile;
        Map.floorElement.appendChild(tile);
    } else {
        if (Map.floor[x][y] != null) {
            Map.floorElement.removeChild(Map.floor[x][y]);
        }
        var tile = create_tile(x, y, "trap");
        Map.floor[x][y] = tile;
        Map.floorElement.appendChild(tile);
    }
}

function stairs(x, y) {
    if (Map.stairs[x][y] != null) {
        var tile = Map.stairs[x][y];
        var rotate = (parseInt(tile.getAttribute("rotate")) + 90) % 360;
        tile.setAttribute("rotate", rotate);
        if (rotate > 0) {
            var cx = (x + 0.5) * Map.tileWidth;
            var cy = (y + 0.5) * Map.tileWidth;
            tile.setAttributeNS(null,"transform", "rotate("+rotate+","+cx+","+cy+")");
        } else {
            tile.removeAttributeNS(null,"transform");
        }
    } else {
        var tile = create_tile(x, y, "stair");
        tile.setAttribute("rotate", 0);
        Map.stairs[x][y] = tile;
        Map.stairsElement.appendChild(tile);
    }
}

function remove_stairs(x, y) {
    if (Map.stairs[x][y] != null) {
        Map.stairsElement.removeChild(Map.stairs[x][y]);
        Map.walls[x][y] = null;
    }
}
      
var Pen = new Object();

function draw_to(evt) {
    var target_x = Math.floor(evt.clientX / Map.tileWidth);
    var target_y = Math.floor(evt.clientY / Map.tileWidth);
    // draw up to the current position (at least once if we just started)
    do {
        if (Map.floor[Pen.x][Pen.y] == null && Pen.type == "empty") {
            var tile = create_tile(Pen.x, Pen.y, "empty");
            Map.floor[Pen.x][Pen.y] = tile;
            Map.floorElement.appendChild(tile);
        } else if (Map.floor[Pen.x][Pen.y] != null && Pen.type == "null") {
            Map.floorElement.removeChild(Map.floor[Pen.x][Pen.y]);
            Map.floor[Pen.x][Pen.y] = null;
        }
        // move pen
        if (Pen.x != target_x) {
            Pen.x += target_x > Pen.x ? 1 : -1;
        } else if (Pen.y != target_y) {
            Pen.y += target_y > Pen.y ? 1 : -1;
        }
    } while (Pen.x != target_x || Pen.y != target_y);
    pen_track(evt);
}

// need to track the pen for keyboard events
function pen_track(evt) {
    Pen.evt = evt;
} 

function pen_down(evt) {
    // init pen
    var x = Math.floor(evt.clientX / Map.tileWidth);
    var y = Math.floor(evt.clientY / Map.tileWidth);
    if (Map.floor[x][y] != null) {
        Pen.type = "null";
    } else {
        Pen.type = "empty";
    }
    Pen.x = x;
    Pen.y = y;
    // draw at least one tile
    draw_to(evt);
    // install new handler
    Map.ui.onmousemove = draw_to;
    // revert to pen tracking on mouse up *anywhere*
    document.onmouseup = function() {
        Map.ui.onmousemove = pen_track;
    }
}

function key_pressed(evt) {
    if(evt.which===63) { // ?
        var help = document.getElementById("help");
        if (help.getAttributeNS(null, "visibility") == "hidden") {
            help.setAttributeNS(null, "visibility", "visible");
        } else {
            help.setAttributeNS(null, "visibility", "hidden");
        }
    } else if (Pen.evt) {
        // extract last known mouse position
        var x = Math.floor(Pen.evt.clientX / Map.tileWidth);
        var y = Math.floor(Pen.evt.clientY / Map.tileWidth);
        if (evt.which===100) { // d
            door(x, y);
        } else if (evt.which===115) { // s
            secret(x, y);
        } else if (evt.which===99) { // c
            concealed(x, y);
        } else if (evt.which===103) { // g
            gate(x, y);
        } else if (evt.which===87) { // W
            remove_wall(x, y);
        } else if (evt.which===116) { // t
            trap(x, y);
        } else if (evt.which===108) { // l
            stairs(x, y);
        } else if (evt.which===108) { // l
            stairs(x, y);
        } else if (evt.which===76) { // L
            remove_stairs(x, y);
        }
    }
}

onload = function() {
    resize(document.getElementById("background"), Map.width * Map.tileWidth, Map.height * Map.tileWidth, linear);
    var help = document.getElementById("help");
    move(help, Map.width * Map.tileWidth + 20 - help.firstElementChild.getAttribute("x"), 20 - help.firstElementChild.getAttribute("y"), bounceEaseOut);
    Map.floorElement = document.getElementById("floor");
    Map.wallsElement = document.getElementById("walls");
    Map.stairsElement = document.getElementById("stairs");
    Map.ui = document.getElementById("ui");
    Map.ui.setAttribute("width",  Map.width * Map.tileWidth);
    Map.ui.setAttribute("height", Map.height * Map.tileWidth);
    // http://javascript.info/tutorial/mouse-events#drag-n-drop
    Map.ui.ondragstart = function() { return false };
    Map.ui.onmousedown = pen_down;
    Map.ui.onmousemove = pen_track;
    document.onkeypress = key_pressed;
    scale_tiles();
    for (var x = 0; x < Map.width; x++) {
        Map.floor[x] = new Array();
        Map.walls[x] = new Array();
        Map.stairs[x] = new Array();
    }
}
]]></script>
  <defs>
    <rect id="empty" width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
    <g id="door" width="10" height="10">
      <rect x="-1.5" y="2" width="3" height="6" fill="white" stroke="black" stroke-width="1"/>
    </g>
    <g id="secret" width="10" height="10">
      <path fill="none" stroke="black" stroke-width="1" d="M 2,3 C -2,1 -3,5 0,5 S 2,9 -2,7" />
    </g>
    <g id="concealed" width="10" height="10">
      <path fill="none" stroke="black" stroke-width="1" d="M 2,3 C -3,1 -3,9 2,7" />
    </g>
    <g id="gate" width="10" height="20">
      <rect x="-2" y="4" width="4" height="12" fill="white" stroke="black" stroke-width="1"/>
    </g>
    <g id="trap" width="10" height="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <rect x="2" y="2" width="6" height="6" fill="white" stroke="black" stroke-width="1"/>
      <line x1="2" y1="2" x2="8" y2="8" stroke="black" stroke-width="0.8"/>
      <line x1="2" y1="8" x2="8" y2="2" stroke="black" stroke-width="0.8"/>
    </g>
    <g id="stair" width="10" height="10">
      <rect width="10" height="20" fill="white" stroke="black" stroke-width="1"/>
      <line x1="0" y1="3" x2="10" y2="3" stroke="black" stroke-width="0.8"/>
      <line x1="1" y1="6" x2="9" y2="6" stroke="black" stroke-width="0.8"/>
      <line x1="2" y1="9" x2="8" y2="9" stroke="black" stroke-width="0.8"/>
      <line x1="3" y1="12" x2="7" y2="12" stroke="black" stroke-width="0.8"/>
      <line x1="4" y1="15" x2="6" y2="15" stroke="black" stroke-width="0.8"/>
    </g>
  </defs>
  <rect id="background" width="0" height="0" fill="lightgray" stroke="black" stroke-width="1"/>
  <g id="floor"/>
  <g id="stairs"/>
  <g id="walls"/>
  <rect id="ui" opacity="0"/>
  <g id="help">
    <rect x="10" y="80" width="400" height="210" fill="ivory" stroke="black" stroke-width="1"/>
    <text id="help" y="100">
      <tspan x="20">Use the mouse to draw the map.</tspan>
      <tspan x="20" dy="20">Use d to draw a door. Use d again to rotate it.</tspan>
      <tspan x="20" dy="20">Use s to draw a secret door. Use s again to rotate it.</tspan>
      <tspan x="20" dy="20">Use c to draw a concealed door. Use c again to rotate it.</tspan>
      <tspan x="20" dy="20">Use g to draw a big gate. Use g again to rotate it.</tspan>
      <tspan x="20" dy="20">Use W to delete any kind of wall feature such as doors.</tspan>
      <tspan x="20" dy="20">Use l to draw some stairs. Use l again to rotate the stairs.</tspan>
      <tspan x="20" dy="20">Use L to delete the stairs.</tspan>
      <tspan x="20" dy="20">Use t to draw a trap. Use t again to delete it.</tspan>
      <tspan x="20" dy="20">Use ? to toggle help. </tspan>
      <a fill="blue" xlink:href="https://github.com/kensanata/gridmapper"><tspan>Source available</tspan></a><tspan>.</tspan>
    </text>
  </g>
</svg>
