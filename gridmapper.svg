<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1"
     xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink">
  <desc>Gridmapper, a simple tool to create dungeon maps</desc>

  <script type="application/javascript"><![CDATA[

/* The original author (Alex Schroeder) has dedicated Gridmapper to
 * the public domain by waiving all of his rights to the work
 * worldwide under copyright law, including all related and
 * neighboring rights, to the extent allowed by law.
 *
 * More information: http://creativecommons.org/publicdomain/zero/1.0/
 *
 * Code style:
 * https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml */

/* These two constants are used when creating new SVG elements and the
 * href attribute linking them to each other.
 */

var svgNs   = 'http://www.w3.org/2000/svg';
var xlinkNs = 'http://www.w3.org/1999/xlink';

/**
 * Stores everything about the map. The element members point to the
 * SVG elements where we'll be adding stuff. We need multiple elements
 * because that's how we make sure that they are painted in the
 * correct order -- a sort of primitive z-axis. The ui Element is a
 * transparent overlay where we'll register the mouse event handlers.
 *
 * If you want to change the size of the map, simply change width and
 * height. 30x30 was the template for the first One Page Dungeon
 * Contest. The tileWidth is the size of one square, in pixels. You
 * can change that as well. Everything shold be scaled accordingly
 * (including the help screen).
 */
var Map = {
  width: 30, // how many columns
  height: 30, // how many rows
  tileWidth: 20, // tile size in pixels
  ui: null, // the SVG element with the event handlers
  pointer: null, // the SVG element for the current position
  floorElement: null, // the SVG element for the floor
  stairsElement: null, // the SVG element for the stairs
  wallsElement: null, // the SVG element for the walls
  data: new Tiles(),
  below: { data: new Tiles(), }, // the data for the map below
  
  /**
   * Initializes the datastructures if necessary. We only need to run
   * this at the very beginning. This does not reset the map in case
   * we're loading an existing file.
   */
  initialize: function() {
    Map.pointer = document.getElementById('pointer');
    Map.floorElement = document.getElementById('floor');
    Map.wallsElement = document.getElementById('walls');
    Map.stairsElement = document.getElementById('stairs');
    Map.below.floorElement = document.getElementById('floor-below');
    Map.below.wallsElement = document.getElementById('walls-below');
    Map.below.stairsElement = document.getElementById('stairs-below');
    // http://javascript.info/tutorial/mouse-events#drag-n-drop
    Map.ui = document.getElementById('ui'); // will be moved, too
    Map.ui.ondragstart = function() { return false };
    Map.ui.onmousedown = penDown;
    Map.ui.onmousemove = Pen.update;
  },

  /**
   * Reset the map. This collects the minimum we need to clean
   * everything up. We run this code before starting the demo, for
   * example. There is no undo.
   */
  reset: function() {
    Map.data = [];
    Map.below.data = [];
    while (Map.floorElement.lastChild) 
      Map.floorElement.removeChild(Map.floorElement.lastChild);
    while (Map.stairsElement.lastChild) 
      Map.stairsElement.removeChild(Map.stairsElement.lastChild);
    while (Map.wallsElement.lastChild) 
      Map.wallsElement.removeChild(Map.wallsElement.lastChild);
    while (Map.below.floorElement.lastChild) 
      Map.below.floorElement.removeChild(Map.below.floorElement.lastChild);
    while (Map.below.stairsElement.lastChild) 
      Map.below.stairsElement.removeChild(Map.below.stairsElement.lastChild);
    while (Map.below.wallsElement.lastChild)
      Map.below.wallsElement.removeChild(Map.below.wallsElement.lastChild);
    moveElements();
    Commands.reset();
  },
  
  /**
   * Grows the data structures along the x axis, if necessary.
   * Animate the process.
   */
  growWithAnimation: function(to_x) {
    // show it
    if (to_x >= Map.width) {
      Map.width = to_x + 1;
      moveElements();
    }
  },

  /**
   * Swaps the current map with the map below. First we move stuff
   * from the Map to a temp object, then we move the stuff below to
   * the map, and finally we move the temp stuff below.
   */
  swap: function() {
      var temp = {};
   
      temp.data = Map.data;

      temp.floorChildren = [];
      temp.wallsChildren = [];
      temp.stairsChildren = [];

      while (Map.floorElement.lastChild)
        temp.floorChildren.push(Map.floorElement.removeChild(Map.floorElement.lastChild));
      while (Map.wallsElement.lastChild)
        temp.wallsChildren.push(Map.wallsElement.removeChild(Map.wallsElement.lastChild));
      while (Map.stairsElement.lastChild)
        temp.stairsChildren.push(Map.stairsElement.removeChild(Map.stairsElement.lastChild));

      Map.data = Map.below.data;

      while (Map.below.floorElement.lastChild)
        Map.floorElement.appendChild(Map.below.floorElement.removeChild(Map.below.floorElement.lastChild));
      while (Map.below.wallsElement.lastChild)
        Map.wallsElement.appendChild(Map.below.wallsElement.removeChild(Map.below.wallsElement.lastChild));
      while (Map.below.stairsElement.lastChild)
        Map.stairsElement.appendChild(Map.below.stairsElement.removeChild(Map.below.stairsElement.lastChild));
      
      Map.below.data = temp.data;

      temp.floorChildren.forEach(function(child, i, array) { Map.below.floorElement.appendChild(child); });
      temp.wallsChildren.forEach(function(child, i, array) { Map.below.wallsElement.appendChild(child); });
      temp.stairsChildren.forEach(function(child, i, array) { Map.below.stairsElement.appendChild(child); });
  },

  swapWithAnimation: function() {
    var duration = 500;

    fadeElementTo(Map.floorElement, 0.2, linear, duration);
    fadeElementTo(Map.wallsElement, 0.2, linear, duration);
    fadeElementTo(Map.stairsElement, 0.2, linear, duration);

    setTimeout(function(){Commands.push(Map.swap, Map.swap)}, duration);

    setTimeout(function(){
      fadeElementTo(Map.floorElement, 1, linear, duration);
      fadeElementTo(Map.wallsElement, 1, linear, duration);
      fadeElementTo(Map.stairsElement, 1, linear, duration);
    }, duration);
  },

  code: function() {
    var source = '';
    var mapping = {door: 'd', secret: '$', concealed: 'c', gate: 'g', wall: 'w',
                   trap: 't', empty: 'f', pillar: 'p', stair: 's', statue: 'b',
                   diagonal: 'n', };
    for (var y = 0; y < Map.height; y++) {
      for (var x = 0; x < Map.width; x++) {
        var walls = Map.data.get(x, y).walls;
        if (walls) {
          walls = walls.sort(function(a,b){
            return parseInt(a.getAttribute('rotate')) - parseInt(b.getAttribute('rotate'));
          });
          for (var i = 0; i < walls.length; i++) {
            var tile = walls[i];
            var type = mapping[tile.type];
            if (type) {
              source += type.repeat(1 + tile.getAttribute('rotate') / 90 - i);
            }
            if (i < walls.length - 1)
              source += '.';
          }
        }
        var tile = Map.data.get(x, y).floor;
        if (tile) {
          if (tile.hasAttribute('rotate')) {
            var rotate = tile.getAttribute('rotate') / 90;
            source += mapping[tile.type].repeat(1 + rotate);
            source += ' ';
          } else {
            source += mapping[tile.type];
          }
        } else {
          source += ' ';
        }
      }
      source += '\n';
    }
    source = source.replace(/ +$/gm,'');
    source = source.replace(/\n+$/,'');
    return source;
  },
};

/**
 *
 */
function Tiles() {
  this.data = [];
  this.get = function(x, y) {
    if (!this.data[x]) {
      this.data[x] = [];
    }
    if (!this.data[x][y]) {
      this.data[x][y] = new Tile();
    }
    return this.data[x][y];
  }
};

/**
 * Stores everything about a single square and its surrounding walls.
 */
function Tile() {
  this.floor = null;
  this.walls = [];
};

/**
 * Holds information about the mouse. We're trying to keep as much of
 * the coordinate messing to ourselves, here. Remember: there is an
 * empty column to the left and an empty row at the top.
 */
var Pen = {
  x: 0,
  y: 0,
  ts: null, // when was the pen last used to draw a door
  type: null, // type of tile we last used
  dir: null, // last movement

  /**
   * Determines the grid position based on a mouse event and returns
   * it. Remember that Wall Mode has one coordinate + 0.5. Also
   * consider that in Wall mode, we need to find a point where the
   * axis changes, "jump a corner".
   */
  position: function(evt) {
    var x = evt.clientX / Map.tileWidth - 1; // empty column on the left
    var y = evt.clientY / Map.tileWidth - 1; // empty row at the top
    if (Pen.type === 'wallMode') {
      var dx = x % 1;
      var dy = y % 1;
      if (Pen.x % 1 !== 0) {
        // on a vertical wall
        if (dx > 0.3 && dx < 0.7 && (dy > 0.8 || dy < 0.2)) {
          return { x: Math.floor(x + 0.5), y: Math.floor(y) + 0.5 };
        }
        // no jumping
        return { x: Math.floor(x + 0.5) - 0.5, y: Math.floor(y) };
      }
      // on a horizontal wall
      if ((dx > 0.8 || dx < 0.2) && dy > 0.3 && dy < 0.7) {
        // jump to a vertical wall
        return { x: Math.floor(x) + 0.5, y: Math.floor(y + 0.5) };
      }
      // no jumping
      return { x: Math.floor(x), y: Math.floor(y + 0.5) - 0.5 };
    }
    // in a square
    return { x: Math.floor(x), y: Math.floor(y) };
  },

  /**
   * Moves the pointer to the current Pen position. If passed a
   * non-null mouse event, determine the new position, first. We call
   * this onmousemove even if we're not drawing because of possible
   * keypress events (which don't come with a position).
   */
  update: function(evt) {
    Pen.ts = null;
    if (evt) {
      var pos = Pen.position(evt);
      Pen.x = pos.x;
      Pen.y = pos.y;
    }
    Map.pointer.setAttribute('x', (Pen.x + 1) * Map.tileWidth);
    Map.pointer.setAttribute('y', (Pen.y + 1) * Map.tileWidth);
  },

  /**
   * Moves the Pen one step closer to the target position. Returns
   * true if the Pen moved, returns false if the Pen is already at
   * the target. As Wall Mode means that one of the coordinates is
   * off by half, this needs special consideration.
   */
  moveTo: function(target) {
    // jump a corner, if necessary
    if (Pen.type === 'wallMode'
        && (Math.abs(Pen.x - target.x) == 0.5
           || Math.abs(Pen.y - target.y) == 0.5)) {
      Pen.x += target.x > Pen.x ? 0.5 : -0.5;
      Pen.y += target.y > Pen.y ? 0.5 : -0.5;
      return true;
    } else if (Pen.x != target.x) {
      Pen.x += target.x > Pen.x ? 1 : -1;
      return true;
    } else if (Pen.y != target.y) {
      Pen.y += target.y > Pen.y ? 1 : -1;
      return true;
    }
    return false;
  },
};

/**
 * Maintains an undo and a redo list. Whenever you do something that
 * the user can undo, you need to call Commands.push with two
 * functions, the how-to-undo-it step and the how-to-do-it step.
 * how-to-do-it will be called once on order to do it. When the user
 * undoes something, our index is decremented and we execute the
 * appropriate undo step. When the user redoes something, our index is
 * incremented and we execute the appropriate redo step. If the user
 * has undone some steps and then pushes new commands, we discard the
 * steps we have undone.
 */
var Commands = {
  i: -1, // where are we in the undo/redo chain
  undoSteps: [],
  redoSteps: [],

  /**
   * Add two closures to the lists. The first one is how to undo a
   * change, the second one is how to do a change. This automatically
   * does the change, too.
   */
  push: function(undoStep, redoStep) {
    // once we're pushing new steps, discard the undone steps
    while (this.undoSteps.length - 1 > this.i) {
      this.undoSteps.pop();
      this.redoSteps.pop();
    }
    this.undoSteps.push(undoStep);
    this.redoSteps.push(redoStep);
    this.i++;
    // finally, execute the last step
    redoStep();
  },
  
  undo: function() {
    if (this.i >= 0) {
      this.undoSteps[this.i--]();
    }
  },
  
  redo: function() {
    if (this.i < this.redoSteps.length - 1) {
      this.redoSteps[++this.i]();
    }
  },
  
  reset: function() {
    undoSteps = [];
    redoSteps = [];
  }
};

/**
 * The user interface code for running a demo. The actual demo is
 * scripted in SVG element with the 'messages' id. Each step of the
 * element makes the tspan elements with matching class visible. If
 * there is a code element with a matching class, its text content is
 * interpreted as a script.
 */
var Demo = {

  /**
   * Stores the code to be run on a timer.
   */
  running: null,

  /**
   * Stores the element containing all the steps.
   */
  element: null,

  /**
   * Allows the user to run the demo.
   */
  start: function () {
    Demo.link('Reset map and run demo', 'Demo.run()', true);
  },

  /**
   * Changes the demo link to something else.
   */
  link: function (text, js, revert) {
    var link = document.getElementById('demo');
    var oldText = link.firstElementChild.firstChild.nodeValue;
    link.firstElementChild.firstChild.nodeValue = text;
    var href = link.getAttributeNS(xlinkNs, 'href');
    link.setAttributeNS(xlinkNs, 'href', 'javascript:' + js);
    // reset after 2s
    if (revert)
      var t = setInterval(function() {
        if (!Demo.running) {
          link.setAttributeNS(xlinkNs, 'href', href);
          link.firstElementChild.firstChild.nodeValue = oldText;
          clearInterval(t);
        }
      }, 2000);
  },

  /**
   * Demo the application.
   */
  run: function () {
    Map.reset();
    Pen.x = 0;
    Pen.y = 0;
    Demo.link('Click to stop demo', 'Demo.stop()', false);
    Map.ui.onmousemove = null;
    Map.ui.onmousedown = null;
    Demo.element = document.getElementById('messages');
    var help = document.getElementById('help').firstElementChild;
    moveElement(Demo.element,
                Demo.element.getBBox().x,
                Demo.element.getBBox().y,
                (Map.width + 2) * Map.tileWidth,
                parseInt(help.getAttribute('height')) + 2 * Map.tileWidth,
                bounceEaseOut);
    Demo.step(1);
  },

  /**
   * Let the demo know that we want to abort.
   */
  stop: function () {
    clearInterval(Demo.running);
    Demo.running = null;
    Demo.clean(null);
    wallModeOff();
    Map.ui.onmousemove = Pen.update;
    Map.ui.onmousedown = penDown;
    Demo.link('Abort! Abort!', 'void', false);
  },

  /**
   * Hides elements from a particular step. Usually called for the previous step.
   */
  clean: function(step) {
    var elements = step
        ? Demo.element.getElementsByClassName('step' + step)
        : Demo.element.children;
    for (var i = 0; i < elements.length; i++) {
      elements[i].setAttribute('visibility', 'collapse');
    }
  },
  
  /**
   * Demo one step and timeout. Note that it's confusing to have more
   * than one code element per step. These are started in order, but
   * if one of them starts delaying using ';', later code will
   * continue executing.
   */
  step: function (step) {
    Demo.clean(step - 1);
    var wait = 5000;
    // show elements for this step and run its code
    elements = Demo.element.getElementsByClassName('step' + step);
    for (var i = 0; i < elements.length; i++) {
      if (elements[i].nodeName === 'tspan') {
        elements[i].setAttribute('visibility', 'visible');
      } else if (elements[i].nodeName === 'code') {
        var code = elements[i].textContent;
        if (code) {
          // Add a delay for every ';' in the code.
          var z = code.match(/;/g);
          if (z)
            wait += 500 * z.length;
          interpret(code);
        }
      }
    }
    // if there was a step, schedule the next step; else quit
    if (elements.length > 0) {
      Demo.running = setTimeout(function() {
        Demo.step(step + 1);
      }, wait);
    } else {
      Demo.stop();
    }
  },
}

/**
 * Defining repeat for Strings, for Chrome/Mac Version 40.0.2214.111
 * (64-bit) as suggested on
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
 */
if (!String.prototype.repeat) {
  String.prototype.repeat = function(count) {
    'use strict';
    if (this == null) {
      throw new TypeError('can\'t convert ' + this + ' to object');
    }
    var str = '' + this;
    count = +count;
    if (count != count) {
      count = 0;
    }
    if (count < 0) {
      throw new RangeError('repeat count must be non-negative');
    }
    if (count == Infinity) {
      throw new RangeError('repeat count must be less than infinity');
    }
    count = Math.floor(count);
    if (str.length == 0 || count == 0) {
      return '';
    }
    // Ensuring count is a 31-bit integer allows us to heavily optimize the
    // main part. But anyway, most current (august 2014) browsers can't handle
    // strings 1 << 28 chars or longer, so:
    if (str.length * count >= 1 << 28) {
      throw new RangeError('repeat count must not overflow maximum string size');
    }
    var rpt = '';
    for (;;) {
      if ((count & 1) == 1) {
        rpt += str;
      }
      count >>>= 1;
      if (count == 0) {
        break;
      }
      str += str;
    }
    return rpt;
  }
}

/* The animation code is taken from these examples:
 * http://javascript.info/tutorial/animation
 */
function animate (opts) {
  var start = new Date();
  var id = setInterval(function() {
    var timePassed = new Date() - start;
    var progress = timePassed / opts.duration;
    if (progress > 1) progress = 1;
    var delta = opts.delta(progress);
    opts.step(delta);
    if (progress === 1) {
      clearInterval(id);
    }
  }, opts.delay || 10);
}

function linear (progress) {
  return progress;
}

function inverse (progress) {
  return 1 - progress;
}

function bounce (progress) {
  for(var a = 0, b = 1; 1; a += b, b /= 2) {
    if (progress >= (7 - 4 * a) / 11) {
      return -Math.pow((11 - 6 * a - 11 * progress) / 4, 2) + Math.pow(b, 2)
    }
  }
}

function makeEaseOut (delta) {
  return function(progress) {
    return 1 - delta(1 - progress);
  }
}

var bounceEaseOut = makeEaseOut(bounce);

function resizeElement (element, toWidth, toHeight, delta, duration) {
  var fromWidth  = element.getBBox().width;  // assuming px
  var fromHeight = element.getBBox().height; // assuming px
  animate({
    delay: 10,
    duration: duration || 1000, // 1 sec by default
    delta: delta,
    step: function(delta) {
      element.setAttribute('width',  fromWidth  + (toWidth  - fromWidth)  * delta);
      element.setAttribute('height', fromHeight + (toHeight - fromHeight) * delta);
    }
  })
}

function moveElement (element, x1, y1, x2, y2, delta, duration) {
  var re = /translate\(.*?\)/;
  var currentX = element.currentX || x1;
  var currentY = element.currentY || y1;
  var oldDx = currentX - x1;
  var oldDy = currentY - y1;
  var newDx = x2 - currentX;
  var newDy = y2 - currentY;
  element.currentX = x2;
  element.currentY = y2;
  if (newDx != 0 || newDy != 0)
    animate({
      delay: 10,
      duration: duration || 1000, // 1 sec by default
      delta: delta,
      step: function(delta) {
        var transform = 'translate(' + (oldDx + newDx * delta) + ',' + (oldDy + newDy * delta) + ')';
        if (!element.hasAttribute('transform'))
          element.setAttribute('transform', transform);
        else if (element.getAttribute('transform').match(re))
          element.setAttribute('transform', element.getAttribute('transform').replace(re, transform));
        else
          element.setAttribute('transform', element.getAttribute('transform') + ',' + transform);
      }
    })
}

function fadeElementTo (element, opacity, delta, duration) {
  var from = Number(element.getAttribute('opacity')) || 1;
  animate({
    delay: 10,
    duration: duration || 1000, // 1 sec by default
    delta: delta,
    step: function(delta) {
      var value = from + (opacity - from) * delta;
      if (value > 0.99) {
        element.removeAttribute('opacity');
      } else {
        element.setAttribute('opacity', value);
      }
    }
  });
};

function moveElements () {
  Map.ui.setAttribute('x', Map.tileWidth);
  Map.ui.setAttribute('y', Map.tileWidth);
  Map.ui.setAttribute('width',  Map.width * Map.tileWidth);
  Map.ui.setAttribute('height', Map.height * Map.tileWidth);
  var elements = document.getElementById('background').children;
  for (var i = 0; i < elements.length; i++) {
    resizeElement(elements[i],
                  Map.width * Map.tileWidth,
                  Map.height * Map.tileWidth,
                  linear, 600);
    moveElement(elements[i],
                parseInt(elements[i].getAttribute('x')),
                parseInt(elements[i].getAttribute('y')),
                Map.tileWidth, // an empty column to the left
                Map.tileWidth, // an empty column at the top
                linear, 500);
  }
  var scale = Map.tileWidth / 20;
  var help = document.getElementById('help');
  if (scale != 1) {
    // from now on, we need to scale all coordinates!
    if (help.hasAttribute('transform')) {
      help.setAttribute('transform', help.getAttribute('transform').replace(/scale\(.*?\)/, 'scale('+scale+','+scale+')'));
    } else {
      help.setAttribute('transform', 'scale('+scale+','+scale+')');
    }
  }
  moveElement(help,
              help.getBBox().x,
              help.getBBox().y,
              // an empty column, the background, and another empty column to the left
              (Map.width + 2) * Map.tileWidth / scale,
              // an empty column at the top
              Map.tileWidth / scale,
              linear, 500);
  var help = document.getElementById('help');
}

/**
 * Offer the current document for download. We store the entire
 * document in a data URI and offer it for downlod using the HTML5
 * download attribute. Chrome 40 will still load that file instead of
 * downloading it. Perhaps a namespace issue? After all, there is no
 * such download attribute for SVG or XHTML.
 */
function download () {
  var source = btoa('<?xml version="1.0" standalone="no"?>\n' +
                    '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n' +
                    '<svg version="1.1"\n' +
                    '     xmlns="http://www.w3.org/2000/svg"\n' +
                    '     xmlns:xlink="http://www.w3.org/1999/xlink">' +
                    // handle Unicode characters
                    unescape(encodeURIComponent(document.documentElement.innerHTML)) +
                    '</svg>');
  var link = document.getElementById('download');
  var text = link.firstElementChild.firstChild.nodeValue;
  link.firstElementChild.firstChild.nodeValue = 'Download';
  var href = link.getAttributeNS(xlinkNs, 'href');
  link.setAttributeNS(null, 'download', 'gridmapper.svg');
  link.setAttributeNS(xlinkNs, 'href', 'data:image/svg+xml;base64,' + source);
  // reset after 10s
  var t = setInterval(function() {
    link.setAttributeNS(xlinkNs, 'href', href);
    link.firstElementChild.firstChild.nodeValue = text;
    clearInterval(t);
  }, 10000);
}

/**
 * Stores the entire document in a sequence of keystrokes with which
 * to recreate it.
 */
function textExport () {
  // do we need to export the map below
  var source = '';
  if (Map.below.floorElement.hasChildNodes()
      || Map.below.wallsElement.hasChildNodes()
      || Map.below.stairsElement.hasChildNodes()) {
    Map.swap();
    source += Map.code() + 'z';
    Map.swap()
    source += Map.code();
  } else {
    source = Map.code();
  }
  source = encodeURIComponent(source);
  var link = document.getElementById('export');
  var text = link.firstElementChild.firstChild.nodeValue;
  link.firstElementChild.firstChild.nodeValue = 'Link';
  var href = link.getAttributeNS(xlinkNs, 'href');
  var location = window.location.href.substr(
    0, window.location.href.length - window.location.search.length)
  link.setAttributeNS(xlinkNs, 'href', location + '?' + source);
  // reset after 10s
  var t = setInterval(function() {
    link.setAttributeNS(xlinkNs, 'href', href);
    link.firstElementChild.firstChild.nodeValue = text;
    clearInterval(t);
  }, 10000);
}

/**
 * Scales all the tiles in the defs element of the SVG. You can add
 * more tiles at whatever scale you want and this code will determine
 * the scale by comparing your tile's width with the tile width in use
 * by the map. The original tiles are all based on a 10x10 grid and
 * are scaled up to 20x20, for example. The easiest way to do this is
 * to use a <g> element and give it an appropriate width attribute.
 */
function scaleTiles () {
  var tiles = document.getElementsByTagName('defs')[0].childNodes;
  for (var i = 0; i < tiles.length; ++i) {
    if (tiles[i].nodeType === Node.ELEMENT_NODE
        && tiles[i].hasAttribute('width')) {
      var scale = Map.tileWidth / tiles[i].getAttribute('width');
      if (scale != 1) {
        tiles[i].setAttribute('transform', 'scale('+scale+','+scale+')');
      }
    }
  }
}

/**
 * Creates a new tile. These tiles are use elements in the SVG
 * referring to an existing definition of the given type. An
 * appropriate id attribute is also generated.
 */
function createTile (x, y, type) {
  var tile = document.createElementNS(svgNs, 'use');
  tile.setAttributeNS(null, 'id', type + '_' + x + '_' + y);
  tile.setAttributeNS(null, 'x', (x + 1) * Map.tileWidth); // empty column to the left
  tile.setAttributeNS(null, 'y', (y + 1) * Map.tileWidth); // empty row at the top
  tile.type = type;
  tile.setAttributeNS(xlinkNs, 'href', '#' + type);
  return tile;
}

/**
 * Returns an unused angle for wall tiles. Provide a preferred angle.
 * Possible values are 0, 90, 180, 270.
 */
function getUnusedAngle (x, y, rotate) {
  var candidate = [rotate,
                   (rotate + 90) % 360,
                   (rotate + 180) % 360,
                   (rotate + 270) % 360];
  var existingWalls = [];
  var walls = Map.data.get(x, y).walls;
  for (var i = 0; i < walls.length; i++) {
    existingWalls.push(walls[i].getAttribute('rotate'));
  }
  search: for (var c = 0; c < 4; c++) {
    for (var i = 0; i < existingWalls.length; i++) {
      if (candidate[c]==existingWalls[i]) {
        continue search;
      }
    }
    return candidate[c];
  }
}

/* Drawing on the walls */

/**
 * Transforms the given tile such that it is rotated by the given
 * angle.
 */
function rotateTile (tile, type, x, y, angle) {
  tile.setAttribute('rotate', angle);
  if (angle === 180 && type === 'concealed') {
    tile.setAttributeNS(null,'transform', 'translate('+Map.tileWidth+',0)');
  } else if (angle > 0) {
    var cx = (x + 1.5) * Map.tileWidth; // empty column to the left
    var cy = (y + 1.5) * Map.tileWidth; // empty row at the top
    tile.setAttributeNS(null,'transform', 'rotate('+angle+','+cx+','+cy+')');
  } else {
    tile.removeAttributeNS(null,'transform');
  }
}

/**
 * Places a tile of the given type on a free section of the wall
 * around the given square.
 */
function wallPlacement (x, y, type) {
  var now = new Date();
  var walls = Map.data.get(x, y).walls;
  if (Pen.type === type
      && walls  && walls.length > 0
      && Pen.ts && now - Pen.ts <= 2000) {
    // we just placed a door: take the last one and rotate it
    var tile = walls[walls.length - 1];
    var old = tile.getAttributeNS(null,'transform');
    var angle = parseInt(tile.getAttribute('rotate'));
    var rotate = getUnusedAngle(x, y, (angle + 90) % 360);
    if (rotate != null) {
      Commands.push(
        function(){
          rotateTile(tile, type, x, y, angle);
        },
        function(){
          rotateTile(tile, type, x, y, rotate);
        });
    }
  } else {
    var rotate = getUnusedAngle(x, y, 0);
    if (rotate != null) {
      var tile = createTile(x, y, type);
      rotateTile(tile, type, x, y, rotate);
      Commands.push(
        function(){
          walls.pop();
          Map.wallsElement.removeChild(tile);
        },
        function(){
          walls.push(tile);
          Map.wallsElement.appendChild(tile);
        });
    }
  }
  Pen.ts = now;
}

/**
 * Draws a wall tile of the given type on the current wall. The
 * current wall only makes sense in Wall Mode. In Wall Mode, one of
 * the two coordinates is +0.5. We determine the angle (0 or 90) and
 * put a tile there.
 */
function wallDraw (x, y, type) {
  var angle = 0;
  if (y % 1 === 0) {
    x = Math.ceil(x);
  } else {
    angle = 90;
    y = Math.ceil(y);
  }
  var i, old;
  var tile = createTile(x, y, type);
  var walls = Map.data.get(x, y).walls;
  rotateTile(tile, type, x, y, angle)
  for (i = 0; i < walls.length; i++) {
    if (parseInt(walls[i].getAttribute('rotate')) == angle) {
      old = walls[i];
      break;
    }
  }
  Commands.push(
    function(){
      Map.wallsElement.removeChild(tile);
      if (old) {
        Map.wallsElement.appendChild(old);
        walls[i] = old;
      } else {
        walls.pop();
      }
    },
    function(){
      if (old) {
        Map.wallsElement.removeChild(old);
        walls[i] = tile;
      } else {
        walls.push(tile);
      }
      Map.wallsElement.appendChild(tile);
    });
}

/**
  * Toggles Wall Mode.
  */
function wallMode (x, y) {
  if (Pen.type === 'wallMode') {
    wallModeOff();
  } else {
    Pen.type = 'wallMode';
    if (Pen.x > 0) {
      Pen.x -= 0.5;
    } else {
      Pen.x += 0.5;
    }
  }
  Pen.update(null);
}

/**
 * Places a tile of the given type in the given square. If in Wall
 * Mode, use the given wall. Otherwise, find a free section around the
 * given square.
 */
function wall (x, y, type) {
  if (Pen.type === 'wallMode') {
    wallDraw(x, y, type);
  } else {
    wallPlacement(x, y, type);
    Pen.type = type;
  }
}

/**
 * Removes a tile from the surrounding walls of the give tile.
 */
function removeWall  (x, y) {
  var walls = Map.data.get(x, y).walls;
  if (Pen.type === 'wallMode') {
    var angle = 0;
    if (y % 1 === 0) {
      x = Math.ceil(x);
    } else {
      angle = 90;
      y = Math.ceil(y);
    }
    if (walls && walls.length > 0) {
      var i, old;
      for (i = 0; i < walls.length; i++) {
        if (parseInt(walls[i].getAttribute('rotate')) == angle) {
          old = walls[i];
          break;
        }
      }
      if (old) {
        Commands.push(
          function(){
            Map.wallsElement.appendChild(old);
            walls.push(old);
          },
          function(){
            Map.wallsElement.removeChild(old);
            walls.splice(i,1);
          });
      }
    }
  } else if (walls && walls.length > 0) {
    // take the last one and remove it
    var tile = walls[walls.length - 1];
    Commands.push(
      function(){
        walls.push(tile);
        Map.wallsElement.appendChild(tile);
      },
      function(){
        walls.pop();
        Map.wallsElement.removeChild(tile);
      });
  }
}

/**
 * Draws a tile on the floor. If the tile it already there, draws
 * floor instead. Stairs are taken care of---they are on a different
 * layer!
 */
function draw (x, y, type) {
  var old = Map.data.get(x, y).floor;
  if (old != null && old.type === type) {
    floor(x, y);
  } else {
    replaceFloor(x, y, old, createTile(x, y, type));
  }
}

/**
 * Replaces the old tile on the floor with a new tile.
 */
function replaceFloor(x, y, old, tile) {
  Commands.push(
    function(){
      Map.floorElement.removeChild(tile);
      if (old != null) {
        Map.floorElement.appendChild(old);
      }
      Map.data.get(x, y).floor = old;
    },
    function(){
      if (old != null) {
        Map.floorElement.removeChild(old);
      }
      Map.data.get(x, y).floor = tile;
      Map.floorElement.appendChild(tile);
    });
}

/**
 * Draws stairs and diagonals on the floor.
 */
function floorRotate (x, y, type) {
  var old = Map.data.get(x, y).floor;
  if (old && old.type === type && old.hasAttribute('rotate')) {
    var angle = parseInt(old.getAttribute('rotate'));
    Commands.push(
      function(){
        rotateTile(old, type, x, y, angle);
      },
      function() {
        rotateTile(old, type, x, y, (angle + 90) % 360);
      });
  } else {
    var tile = createTile(x, y, type);
    tile.setAttribute('rotate', 0);
    replaceFloor(x, y, old, tile);
  }
}

/**
 * Draws or erases a floor tile.
 */
function floor (x, y) {
  var old   = Map.data.get(x, y).floor;
  if (!old || old.type != 'empty') {
    replaceFloor(x, y, old, createTile(x, y, 'empty'));
  } else {
    replaceFloor(x, y, old, null);
  }
}

/* This is where we draw (or erase) floor tiles. The key point to
 * remember is that we might not get a mouse event for every
 * coordinate. That's why we need to store where we want to draw to
 * (our target) and start drawing at our current position (the pen).
 * We do this at least once in order to support clicks without mouse
 * movement. Then we start a loop: as long as the pen hasn't reached
 * the target, we change x or y by 1 and draw another tile. As we're
 * creating closures for Commands, we need to do this in a factory.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#Creating_closures_in_loops.3A_A_common_mistake
 */

function drawToCommand (x, y, tile, type) {
  var remove = function(){
    Map.floorElement.removeChild(tile);
    Map.data.get(x, y).floor = null;
  };
  var add = function(){
    Map.data.get(x, y).floor = tile;
    Map.floorElement.appendChild(tile);
  };
  if (type === 'add') {
    Commands.push(remove, add); // add new tile
  } else {
    Commands.push(add, remove); // remove existing tile
  }
}

function drawTo (evt) {
  var target = Pen.position(evt);
  // draw up to the current position (at least once if we just started)
  do {
    if (!Map.data.get(Pen.x, Pen.y).floor && Pen.type === 'empty') {
      drawToCommand(Pen.x, Pen.y, createTile(Pen.x, Pen.y, 'empty'), 'add');
    } else if (Map.data.get(Pen.x, Pen.y).floor && Pen.type === 'null') {
      drawToCommand(Pen.x, Pen.y, Map.data.get(Pen.x, Pen.y).floor, 'remove');
    }
  } while (Pen.moveTo(target));
  Pen.update(evt);
}

/**
 * Sets the Pen down, ready for drawing. When setting down the pen
 * (onmousedown, penDown), we look at the current tile. If it's the
 * empty floor tile, we'll want to erase it. If there is no floor tile
 * (null), we'll want to draw an empty floor tile. We store this
 * information in the Pen type and as we keep on drawing (onmousemove,
 * drawTo), we don't change it.
 */
function penDown (evt) {
  wallModeOff();
  Pen.update(evt);
  if (Map.data.get(Pen.x, Pen.y).floor) {
    Pen.type = 'null';
  } else {
    Pen.type = 'empty';
  }
  // draw at least one tile
  drawTo(evt);
  // install new handler
  Map.ui.onmousemove = drawTo;
  // revert to pen tracking on mouse up *anywhere*
  document.onmouseup = function() {
    Map.ui.onmousemove = Pen.update;
  }
}

/**
 * Puts the pointer back into a square and ends Wall Mode.
 * Call this whenever you're acting on squares.
 */
function wallModeOff () {
  Pen.x = Math.ceil(Pen.x);
  Pen.y = Math.ceil(Pen.y);
  Pen.update(null);
  Pen.type = null;
}

/**
 * Moves the pointer around. It handles both moving from square to
 * sqare as well as moving from wall to wall (where one of the
 * coordinates is off by 0.5).
 */
function move (dir) {
  switch (dir) {
  case 'left':
    if (Pen.x > 0)
      Pen.x--;
    break;
  case 'right':
    Map.growWithAnimation(Pen.x + 1);
    Pen.x++;
    break;
  case 'up':
    if (Pen.y > 0)
      Pen.y--;
    break;
  case 'down':
    if (Pen.y + 1 >= Map.height) {
      Map.height++;
      moveElements();
    }
    Pen.y++;
    break;
  }
  // Example: when moving down from 1 to 2 and right to 3, we want to
  // switch position on the grid and end up on 4. So we need to adjust
  // the position by (-0.5,-0.5):
  //
  //  x→
  // y  |   |
  // ↓--+---+---
  //    1   |
  //  --+-4-+---
  //    2   3
  //  --+---+---
  //    |   |
  //
  // If we moved first right and then down, we would end up in the same
  // position.
  if (Pen.type === 'wallMode') {
    var now = new Date();
    if (Pen.dir && Pen.ts && now - Pen.ts <= 500) {
      if (Pen.dir=='left' && dir=='down'
          || Pen.dir=='down' && dir=='left') {
        Pen.x += 0.5;
        Pen.y -= 0.5;
      } else if (Pen.dir=='left' && dir=='up'
                 || Pen.dir=='up' && dir=='left') {
        Pen.x += 0.5;
        Pen.y += 0.5;
      } else if (Pen.dir=='right' && dir=='down'
                 || Pen.dir=='down' && dir=='right') {
        Pen.x -= 0.5;
        Pen.y -= 0.5;
      } else if (Pen.dir=='right' && dir=='up'
                 || Pen.dir=='up' && dir=='right') {
        Pen.x -= 0.5;
        Pen.y += 0.5;
      }

    }
  }
  Pen.update(null);
  Pen.dir = dir;
  Pen.ts = now; // must come after Pen.update
}

/**
 * Extract key from KeyboardEvent
 * Basic source from http://javascript.info/tutorial/keyboard-events#processing-the-character-keypress
 */
function getChar(event) {
  if (event.which == null) {
    return String.fromCharCode(event.keyCode) // IE character keys
  } else if (event.which!=0 && event.charCode!=0) {
    return String.fromCharCode(event.which) // the rest character keys
  } else if (event.type == 'keydown') { // special key
    if(event.key && event.key.length != 1) return event.key; // Firefox
    if(event.keyIdentifier && event.keyIdentifier.substring(0,2) !== 'U+') return event.keyIdentifier; // Chrome
  }
  return null; // ignore second key event
}

/**
 * Processes key press events and single character strings (in case
 * the interpreter is feeding us some). Many of the key commands need
 * a 'current' position. We determine it by looking at the Pen. It's
 * position is always tracked (onmousemove, Pen.update).
 */
function keyPressed (evt) {
  // Could be a string when running interpreted code.
  var key = evt;

  // When running the demo, ignore key events from the browser.
  if (!Demo.running) {
    if(evt instanceof KeyboardEvent){
      key = getChar(evt);
      if(key === null) return; // ignore one of onkeydown or onkeypress event
    }
  }

  switch (key) {
  case '?':
    var help = document.getElementById('help');
    if (help.getAttributeNS(null, 'visibility') === 'hidden') {
      help.setAttributeNS(null, 'visibility', 'visible');
    } else {
      help.setAttributeNS(null, 'visibility', 'hidden');
    }
    break;
  case 'u':
    Commands.undo();
    break;
  case 'r':
    Commands.redo();
    break;
  case 'ArrowDown':
  case 'Down':
    if (evt.shiftKey) {
      wallModeOff();
      floor(Pen.x, Pen.y);
    }
    move('down');
    break;
  case 'ArrowUp':
  case 'Up':
    if (evt.shiftKey) {
      wallModeOff();
      floor(Pen.x, Pen.y);
    }
    move('up');
    break;
  case 'ArrowLeft':
  case 'Left':
    if (evt.shiftKey) {
      wallModeOff();
      floor(Pen.x, Pen.y);
    }
    move('left');
    break;
  case 'ArrowRight':
  case 'Right':
  case ' ':
    if (evt.shiftKey) {
      wallModeOff();
      floor(Pen.x, Pen.y);
    }
    move('right');
    break;
  case 'f':
    wallModeOff();
    floor(Pen.x, Pen.y);
    break;
  case '\n':
  case 'Enter':
    wallModeOff();
    Pen.x = 0;
    move('down');
    break;
  case 'd':
    wall(Pen.x, Pen.y, 'door');
    break;
  case '$':
    wall(Pen.x, Pen.y, 'secret');
    break;
  case 'c':
    wall(Pen.x, Pen.y, 'concealed');
    break;
  case 'g':
    wall(Pen.x, Pen.y, 'gate');
    break;
  case 'w':
    wall(Pen.x, Pen.y, 'wall');
    break;
  case 'm':
    wallMode(Pen.x, Pen.y);
    break;
  case 'x':
    removeWall(Pen.x, Pen.y);
    break;
  case 'p':
    wallModeOff();
    draw(Pen.x, Pen.y, 'pillar');
    break;
  case 't':
    wallModeOff();
    draw(Pen.x, Pen.y, 'trap');
    break;
  case 'b':
    wallModeOff();
    draw(Pen.x, Pen.y, 'statue');
    break;
  case 's':
    wallModeOff();
    floorRotate(Pen.x, Pen.y, 'stair');
    break;
  case 'n':
    wallModeOff();
    floorRotate(Pen.x, Pen.y, 'diagonal');
    break;
  case 'z':
    Map.swapWithAnimation();
    break;
  default:
    console.log('Gridmapper does not know how to handle "'+ key + '"');
    break;
  }
}

/**
 * Interprets a sequence of characters as a script. A '.' will reset
 * the Pen's timestamp, simulating a pause (to prevent rotating the
 * last tile). A ';' will cause a timeout. This is used for the demo.
 * Since we don't want to freeze the computer, all the heavy lifting
 * is done by another function which knows how to finish the job.
 */
function interpret (code) {
  interpretCont(code, 0);
}

/**
 * Continues the interpretation where we left oft. The variables are
 * not initialized so that we can simply pick up where we left off.
 * This is because we want to interrupt the computation using
 * timeouts.
 */
function interpretCont (code, i) {
  for (; i < code.length; i++) {
    var advance = null;
    switch(code[i]) { // needs charAt?
    case '.': Pen.ts = null; break;
    case ';':
      setTimeout(function() {
        interpretCont(code, i + 1);
      }, 500);
      return; // end!
    case '(':
      var match = code.substr(i).match(/(\d+(?:\.\d+)?),(\d+(?:\.\d+)?)/);
      if (match) {
        // no longer ints!
        x = Number(match[1]);
        y = Number(match[2]);
        if (Pen.moveTo({x: x, y: y})) {
          Pen.update(null);
          setTimeout(function() {
            interpretCont(code, i);
          }, 100);
          return; // end!
        }
        i += match[0].length;
      }
      break;
    case '-':
      advance = 'left';
      break;
    case 'z':
      // Make sure we can undo this step.
      Commands.push(Map.swap, Map.swap);
      // When loading from an URL, we need to reposition the Pen. When
      // running the Demo, we do not.
      if (!Demo.running) {
        Pen.x = 0;
        Pen.y = 0;
        Pen.type = null;
      }
      break;
    case 'f':
    case 't':
    case 'p':
    case 'b':
      advance = 'right';
      // fall through to default
    default:
      keyPressed(code[i]);
    }
    // advance unless we're going to move elsewhere (peek ahead)
    if (advance && code[i+1] !== '\n' && code[i] !== '(')
      move(advance);
  }
}

/**
 * Recreates the models based on existing SVG elements (if loading a
 * saved file) and the URL (if loading a page). When loading a file,
 * We go through the elements and add the appropriate data to the
 * various data models. When loading from a URL, we look at the
 * keyword parameter and interpret it as a key sequence one might
 * conceivably type. The only difference is the . character which is
 * used to simulate a little pause (to prevent doors from rotating).
 */
function recreateModel () {
  var re = /^\w+_(\d+)_(\d+)$/;
  recreateModelFor(re, Map.below.data, Map.below.floorElement);
  recreateModelFor(re, Map.below.data, Map.below.stairsElement);
  recreateModelForDoors(re, Map.below.data, Map.below.wallsElement);
  recreateModelFor(re, Map.data, Map.floorElement);
  recreateModelFor(re, Map.data, Map.stairsElement);
  recreateModelForDoors(re, Map.data, Map.wallsElement);
  // skip initial '?'
  interpret(decodeURIComponent(window.location.search).substring(1));
  moveElements(); // animate grows in the end
}

/**
 * Recreates one particular model based on a matching SVG element.
 * This looks only at id attributes.
 */
function recreateModelFor (re, data, element) {
  for (var i = 0; i < element.children.length; i++) {
    var result = element.children[i].getAttribute('id').match(re);
    if (result) {
      var x = result[1];
      var y = result[2];
      data.get(x, y).floor = element.children[i];
    }
  }
}

/**
 * Recreates one particular wall model on a matching SVG element.
 * This looks only at id attributes.
 */
function recreateModelForDoors (re, data, element) {
  for (var i = 0; i < element.children.length; i++) {
    var result = element.children[i].getAttribute('id').match(re);
    if (result) {
      var x = result[1];
      var y = result[2];
      data.get(x, y).walls.push(element.children[i]);
    }
  }
}

/**
 * Initialize the user interface.
 */
function initialize () {
  scaleTiles();
  document.onkeydown = keyPressed; // capture arrow keys
  document.onkeypress = keyPressed; // capture character keys
  Map.initialize(); // don't reset the Map so we can load from a file
  Pen.update(null); // show it
  recreateModel(); // create model
}

onload = initialize;
]]></script>
  <defs>
    <rect id="cursor" width="10" height="10" fill="forestgreen" opacity="0.2"/>
    <rect id="empty" width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
    <g id="wall" width="10">
      <line x1="0" y1="0" x2="0" y2="10" stroke="black" stroke-width="3" stroke-linecap="round"/>
    </g>
    <g id="door" width="10">
      <rect x="-1.5" y="2" width="3" height="6" fill="white" stroke="black" stroke-width="1"/>
    </g>
    <g id="secret" width="10">
      <path fill="none" stroke="black" stroke-width="1" d="M 2,3 C -2,1 -3,5 0,5 S 2,9 -2,7" />
    </g>
    <g id="concealed" width="10">
      <path fill="none" stroke="black" stroke-width="1" d="M 2,3 C -3,1 -3,9 2,7" />
    </g>
    <g id="gate" width="10">
      <rect x="-2" y="4" width="4" height="12" fill="white" stroke="black" stroke-width="1"/>
    </g>
    <g id="pillar" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <circle cx="5" cy="5" r="2" fill="black"/>
    </g>
    <g id="statue" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <circle cx="5" cy="5" r="3.5" fill="none" stroke="black" stroke-width="0.5"/>
      <path fill="black" d="M 2,4 H 8 L 3,7.5 5,2 7,7.5 Z"/>
    </g>
    <g id="trap" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <rect x="2" y="2" width="6" height="6" fill="white" stroke="black" stroke-width="1"/>
      <line x1="2" y1="2" x2="8" y2="8" stroke="black" stroke-width="0.8"/>
      <line x1="2" y1="8" x2="8" y2="2" stroke="black" stroke-width="0.8"/>
    </g>
    <g id="diagonal" width="10">
      <rect width="10" height="10" fill="white" stroke="black" stroke-width="1"/>
      <path fill="black" d="M 0,0 H 10 L 0,10 Z"/>
    </g>
    <g id="stair" width="10">
      <rect width="10" height="20" fill="white" stroke="black" stroke-width="1"/>
      <line x1="0" y1="3" x2="10" y2="3" stroke="black" stroke-width="0.8"/>
      <line x1="1" y1="6" x2="9" y2="6" stroke="black" stroke-width="0.8"/>
      <line x1="2" y1="9" x2="8" y2="9" stroke="black" stroke-width="0.8"/>
      <line x1="3" y1="12" x2="7" y2="12" stroke="black" stroke-width="0.8"/>
      <line x1="4" y1="15" x2="6" y2="15" stroke="black" stroke-width="0.8"/>
    </g>
    <g id="curved-arrow">
      <path fill="none" stroke="forestgreen" stroke-width="1" d="M 0,30 C 0,9 9,0 30,0" />
      <path fill="forestgreen" d="M 23,5 L 30,0 23,-5 Z" />
    </g>
  </defs>
  <g id="background">
    <rect x="20" y="20" width="0" height="0" fill="lightgrey" stroke="black" stroke-width="1"/>
  </g>
  <g id="floor-below" opacity="0.2"/>
  <g id="stairs-below" opacity="0.2"/>
  <g id="walls-below" opacity="0.2"/>
  <g id="floor"/>
  <g id="stairs"/>
  <use id="pointer" xlink:href="#cursor"/>
  <g id="walls"/>
  <rect id="ui" opacity="0"/>

  <style><![CDATA[
  text { font: 14px 'Courier New', Courier, monospace; }
  .key { fill: forestgreen; font-weight: bold; }
  ]]></style>

  <g id="help">
    <rect x="10" y="80" width="440" height="530" fill="ivory" stroke="black" stroke-width="1"/>
    <a xlink:href="https://alexschroeder.ch/wiki/Gridmapper">
      <text x="460" y="90" transform="rotate(90,460,90)" style="font-weight: bold">Gridmapper</text>
    </a>
    <use x="30" y="90" xlink:href="#empty"/>
    <use x="30" y="120" xlink:href="#trap"/>
    <use x="150" y="120" xlink:href="#pillar"/>
    <use x="290" y="120" xlink:href="#statue"/>
    <use x="30" y="150" xlink:href="#empty"/>
    <use x="30" y="150" xlink:href="#door"/>
    <use x="30" y="180" xlink:href="#empty"/>
    <use x="30" y="180" xlink:href="#secret"/>
    <use x="30" y="210" xlink:href="#empty"/>
    <use x="30" y="210" xlink:href="#concealed"/>
    <use x="30" y="240" xlink:href="#empty"/>
    <use x="30" y="240" xlink:href="#wall"/>
    <use x="30" y="270" xlink:href="#empty"/>
    <use x="30" y="290" xlink:href="#empty"/>
    <use x="30" y="270" xlink:href="#gate"/>
    <use x="30" y="320" xlink:href="#stair"/>
    <use x="30" y="370" xlink:href="#diagonal"/>
    <use x="30" y="400" xlink:href="#empty"/>
    <use x="30" y="430" xlink:href="#empty"/>
    <use x="20" y="430" xlink:href="#cursor"/>

    <g>
      <use x="370" y="260" xlink:href="#empty" opacity="0.3"/>
      <use x="350" y="280" xlink:href="#empty" opacity="0.3"/>
      <use x="370" y="280" xlink:href="#empty"/>
      <use x="370" y="280" xlink:href="#cursor"/>
      <use x="390" y="280" xlink:href="#empty" opacity="0.3"/>
      <use x="370" y="300" xlink:href="#empty" opacity="0.3"/>
      <rect x="366" y="288" width="8" height="24" fill="olive" stroke="black" stroke-width="2"/>
      <use x="370" y="280" transform="rotate(90,380,290)" xlink:href="#gate"/>
      <use x="370" y="280" transform="rotate(180,380,290)" xlink:href="#gate"/>
      <use x="370" y="280" transform="rotate(270,380,290)" xlink:href="#gate"/>
      <text x="335" y="295" style="fill: olive; font-weight: bold;">1</text>
      <text x="375" y="255" class="key">2</text>
      <text x="415" y="295" class="key">3</text>
      <text x="375" y="335" class="key">4</text>
      <use x="340" y="250" xlink:href="#curved-arrow"/>
      <use x="340" y="250" xlink:href="#curved-arrow" transform="rotate(90,380,290)"/>
      <use x="340" y="250" xlink:href="#curved-arrow" transform="rotate(180,380,290)"/>
      <use x="340" y="250" xlink:href="#curved-arrow" transform="rotate(270,380,290)"/>
    </g>

    <text y="105">
      <tspan x="60">Use the mouse to draw and erase the floor</tspan>
      <tspan x="60" dy="30"><tspan class="key">t</tspan> : trap</tspan>
      <tspan x="180"><tspan class="key">p</tspan> : pillar</tspan>
      <tspan x="320"><tspan class="key">b</tspan> : statue</tspan>
      <tspan x="60" dy="30"><tspan class="key">d</tspan> : a door, repeat to rotate</tspan>
      <tspan x="60" dy="30"><tspan class="key">$</tspan> : a secret door, repeat to rotate</tspan>
      <tspan x="60" dy="30"><tspan class="key">c</tspan> : a concealed door, repeat to rotate</tspan>
      <tspan x="60" dy="30"><tspan class="key">w</tspan> : wall, repeat to rotate</tspan>
      <tspan x="60" dy="30"><tspan class="key">g</tspan> : a gate, repeat to rotate</tspan>
      <tspan x="60" dy="50"><tspan class="key">s</tspan> : stairs, repeat to rotate</tspan>
      <tspan x="60" dy="50"><tspan class="key">n</tspan> : diagonal, repeat to rotate</tspan>
      <tspan x="60" dy="30"><tspan class="key">f</tspan> : floor / erase</tspan>
      <tspan x="60" dy="30" class="key">m</tspan><tspan> : enter / leave Wall Mode</tspan>
      <tspan x="60" dy="20" class="key">x</tspan><tspan> : clear wall</tspan>
      <tspan x="60" dy="20" class="key">u</tspan><tspan> : undo</tspan>
      <tspan x="60" dy="20" class="key">r</tspan><tspan> : redo</tspan>
      <tspan x="60" dy="20" class="key">z</tspan><tspan> : switch layer</tspan>
      <tspan x="60" dy="20" class="key">?</tspan><tspan> : toggle help</tspan>
      <a id="download" fill="blue" xlink:href="javascript:download()">
	<tspan x="30" dy="30">Prepare Download</tspan>
      </a>
      <tspan> / </tspan>
      <a id="export" fill="blue" xlink:href="javascript:textExport()">
	<tspan>Prepare Link</tspan>
      </a>
      <a fill="blue" xlink:href="https://alexschroeder.ch/">
	<tspan x="30" dy="20">Alex Schroeder</tspan>
      </a>
      <tspan> / </tspan>
      <a fill="blue" xlink:href="https://github.com/kensanata/gridmapper">
	<tspan>Source</tspan>
      </a>
      <tspan> / </tspan>
      <a id="demo" fill="blue" xlink:href="javascript:Demo.start()">
	<tspan>Demo</tspan>
      </a>
    </text>

    <text x="210" y="485">
      <tspan class="key">Space</tspan><tspan> : move right</tspan>
      <tspan x="210" dy="20" class="key">Enter</tspan><tspan> : begin new line</tspan>
      <tspan x="210" dy="20" class="key">Arrows</tspan><tspan> : move around</tspan>
      <tspan x="210" dy="20" class="key">Shift Arr.</tspan><tspan> : floor / erase</tspan>
    </text>
  </g>

  <text id="messages" visibility="hidden">
    <tspan class="step1" x="0" y="0">Hello! This is the demo!</tspan>
    <tspan class="step1" x="0" dy="20">We're going to show you how to use this thing.</tspan>
    <code class="step1">(10,10)</code>

    <tspan class="step2" x="0" y="0">You can move around the map using your mouse.</tspan>
    <tspan class="step2" x="0" dy="20">Or you can use the</tspan>
    <tspan class="step2 key">Arrow keys</tspan>
    <tspan class="step2">to move around.</tspan>
    <code class="step2">(20,10)(20,20)(10,20)(10,10)</code>

    <tspan class="step3" x="0" y="0">You can draw the floor using your mouse.</tspan>
    <tspan class="step3" x="0" dy="20">Or you can use</tspan>
    <tspan class="step3 key">Shift</tspan>
    <tspan class="step3">and the</tspan>
    <tspan class="step3 key">Arrow keys</tspan><tspan class="step3">.</tspan>
    <code class="step3">(13,11)ffff(13,12)ffff(13,13)ffff(13,14)ffff(13,15)ffff</code>

    <tspan class="step4" x="0" y="0">In general I recomend using the</tspan>
    <tspan class="step4 key">Arrow keys</tspan>
    <tspan class="step4">to move.</tspan>
    <tspan class="step4" x="0" dy="20">Use</tspan>
    <tspan class="step4 key">f</tspan>
    <tspan class="step4">to draw or erase the floor.</tspan>
    <code class="step4">(14,16)ff(14,17)ff(11,18)ffffff(11,19)ffffff(11,20)ffffff;ffff-;f--;f--;f--f-</code>

    <tspan class="step5" x="0" y="0">Things like traps, statues and pillars are easy.</tspan>
    <tspan class="step5" x="0" dy="20">Just press the appropriate key:</tspan>
    <tspan class="step5 key">t</tspan><tspan class="step5">,</tspan>
    <tspan class="step5 key">b</tspan><tspan class="step5">,</tspan>
    <tspan class="step5 key">p</tspan><tspan class="step5">.</tspan>
    <code class="step5">(12,19)t;(11,19)b;(11,18)ppp;(11,20)ppp</code>

    <tspan class="step6" x="0" y="0">Doors are trickier. Press</tspan>
    <tspan class="step6 key">d</tspan>
    <tspan class="step6">to rotate the door.</tspan>
    <tspan class="step6" x="0" dy="20">Watch: left, top, right, bottom, and back to left.</tspan>
    <code class="step6">(17,12);d;d;d;d;d</code>

    <tspan class="step7" x="0" y="0">To remove a door you added</tspan>
    <tspan class="step7" x="0" dy="20">press</tspan>
    <tspan class="step7 key">x</tspan><tspan class="step7">.</tspan>
    <code class="step7">(17,13);d;x;d;x;d;x</code>

    <tspan class="step8" x="0" y="0">Secret doors and conceiled doors work just the same.</tspan>
    <tspan class="step8" x="0" dy="20">Press</tspan>
    <tspan class="step8 key">$</tspan>
    <tspan class="step8">and</tspan>
    <tspan class="step8 key">c</tspan>
    <tspan class="step8">to set and rotate them into place.</tspan>
    <code class="step8">(17,14)dff(18,15)fff(19,16)ff;c;fff(21,17)fff(23,17);$;$;$;(21,18)fff</code>

    <tspan class="step9" x="0" y="0">Stairs work just the same.</tspan>
    <tspan class="step9" x="0" dy="20">Press </tspan><tspan class="step9 key">s</tspan>
    <tspan class="step9">to set and rotate them into place.</tspan>
    <code class="step9">(11,12)s;s;s;s;(17,12)fs;s;s;s  </code>

    <tspan class="step10" x="0" y="0">You can draw on two layers.</tspan>
    <tspan class="step10" x="0" dy="20">Press</tspan>
    <tspan class="step10 key">z</tspan>
    <tspan class="step10">to switch layers.</tspan>
    <code class="step10">z(21,11)fff(20,12)ffff(21,13)fff;z</code>

    <tspan class="step11" x="0" y="0">Gates can be also be confusing, but see diagram!</tspan>
    <tspan class="step11" x="0" dy="20">Press </tspan><tspan class="step11 key">g</tspan>
    <tspan class="step11">to set and rotate them into place.</tspan>
    <code class="step11">(15,16);g;g</code>

    <tspan class="step12" x="0" y="0">Press </tspan><tspan class="step12 key">n</tspan>
    <tspan class="step12">to place and rotate diagonals.</tspan>
    <code class="step12">(17,15);n;n;n;n(18,14);n;n</code>

    <tspan class="step13" x="0" y="0">You can draw walls using</tspan>
    <tspan class="step13 key">w</tspan><tspan class="step13">.</tspan>
    <tspan class="step13" x="0" dy="20">Thus, walls work just like doors.</tspan>
    <code class="step13">(16,18);$(16,19);w(16,20);w</code>

    <tspan class="step14" x="0" y="0">This gets tedious very fast.</tspan>
    <tspan class="step14" x="0" dy="20">Use</tspan>
    <tspan class="step14 key">m</tspan>
    <tspan class="step14">to enter</tspan>
    <tspan class="step14" style="font-weight: bold">Wall Mode</tspan><tspan class="step14">.</tspan>
    <tspan class="step14" x="0" dy="20">Note the shift by half a square!</tspan>
    <code class="step14">z(21,11);m</code>

    <tspan class="step15" x="0" y="0" style="font-weight: bold">Wall Mode</tspan>
    <tspan class="step15">keeps the cursor on the walls.</tspan>
    <tspan class="step15" x="0" dy="20">Doors and walls no longer rotate.</tspan>
    <code class="step15"> w; w;(21.5,13)w; w</code>

    <tspan class="step16" x="0" y="0">Move from wall to wall and use</tspan>
    <tspan class="step16 key">d</tspan><tspan class="step16">,</tspan>
    <tspan class="step16 key">$</tspan><tspan class="step16">,</tspan>
    <tspan class="step16 key">c</tspan><tspan class="step16">,</tspan>
    <tspan class="step16 key">g</tspan><tspan class="step16">,</tspan>
    <tspan class="step16 key">w</tspan><tspan class="step16"> or</tspan>
    <tspan class="step16 key">x</tspan><tspan class="step16">.</tspan>
    <code class="step16">(21,11.5)d; d; d;(21,12.5)d; d; d;(23.5,12)$m</code>
    <tspan class="step16" x="0" dy="20">Use </tspan>
    <tspan class="step16 key">m</tspan>
    <tspan class="step16">to leave Wall Mode.</tspan>

    <tspan class="step17" x="0" y="0">Well, that's it. The rest is up to you.</tspan>
    <tspan class="step17" x="0" dy="20">What lies beyond the secret doors to the east?</tspan>
    <code class="step17">z</code>

  </text>
</svg>
